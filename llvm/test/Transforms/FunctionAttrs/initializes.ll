; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-attributes --version 4
; RUN: opt -passes=function-attrs -S < %s | FileCheck %s

define void @f1(ptr %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f1(
; CHECK-SAME: ptr nocapture writeonly initializes((0, 8)) [[P:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    store i64 123, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  store i64 123, ptr %p
  ret void
}

define void @f2(ptr %p, i1 %i) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f2(
; CHECK-SAME: ptr nocapture writeonly initializes((0, 8)) [[P:%.*]], i1 [[I:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[I]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store i64 123, ptr [[P]], align 4
; CHECK-NEXT:    br label [[END:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store i64 321, ptr [[P]], align 4
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  br i1 %i, label %bb1, label %bb2
bb1:
  store i64 123, ptr %p
  br label %end
bb2:
  store i64 321, ptr %p
  br label %end
end:
  ret void
}

define void @f3(ptr %p, ptr %p2) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f3(
; CHECK-SAME: ptr [[P:%.*]], ptr nocapture writeonly initializes((0, 8)) [[P2:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    store ptr [[P]], ptr [[P2]], align 8
; CHECK-NEXT:    ret void
;
  store ptr %p, ptr %p2
  ret void
}

define void @f4(ptr %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
; CHECK-LABEL: define void @f4(
; CHECK-SAME: ptr nocapture [[P:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    [[A:%.*]] = load i32, ptr [[P]], align 4
; CHECK-NEXT:    store i32 123, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  %a = load i32, ptr %p
  store i32 123, ptr %p
  ret void
}

define void @f5(ptr %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
; CHECK-LABEL: define void @f5(
; CHECK-SAME: ptr nocapture [[P:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[A:%.*]] = load i32, ptr [[P]], align 4
; CHECK-NEXT:    store i64 123, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  %a = load i32, ptr %p
  store i64 123, ptr %p
  ret void
}

declare void @use(ptr)

define void @f6(ptr %p) {
; CHECK-LABEL: define void @f6(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    call void @use(ptr [[P]])
; CHECK-NEXT:    store i64 123, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  call void @use(ptr %p)
  store i64 123, ptr %p
  ret void
}

define void @f7(ptr %p) {
; CHECK-LABEL: define void @f7(
; CHECK-SAME: ptr initializes((0, 8)) [[P:%.*]]) {
; CHECK-NEXT:    store i64 123, ptr [[P]], align 4
; CHECK-NEXT:    call void @use(ptr [[P]])
; CHECK-NEXT:    ret void
;
  store i64 123, ptr %p
  call void @use(ptr %p)
  ret void
}

define void @f8(ptr %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f8(
; CHECK-SAME: ptr nocapture writeonly initializes((8, 12)) [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P]], i64 8
; CHECK-NEXT:    store i32 123, ptr [[G]], align 4
; CHECK-NEXT:    ret void
;
  %g = getelementptr i8, ptr %p, i64 8
  store i32 123, ptr %g
  ret void
}

define void @f9(ptr %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f9(
; CHECK-SAME: ptr nocapture writeonly initializes((0, 8)) [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P]], i64 4
; CHECK-NEXT:    store i32 123, ptr [[G]], align 4
; CHECK-NEXT:    store i32 123, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  %g = getelementptr i8, ptr %p, i64 4
  store i32 123, ptr %g
  store i32 123, ptr %p
  ret void
}

define void @f10(ptr %p, i1 %i) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f10(
; CHECK-SAME: ptr nocapture writeonly initializes((4, 8)) [[P:%.*]], i1 [[I:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P]], i64 4
; CHECK-NEXT:    br i1 [[I]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store i64 123, ptr [[G]], align 4
; CHECK-NEXT:    br label [[END:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store i64 321, ptr [[P]], align 4
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %g = getelementptr i8, ptr %p, i64 4
  br i1 %i, label %bb1, label %bb2
bb1:
  store i64 123, ptr %g
  br label %end
bb2:
  store i64 321, ptr %p
  br label %end
end:
  ret void
}

define void @f11(ptr %p, i1 %i) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f11(
; CHECK-SAME: ptr nocapture writeonly [[P:%.*]], i1 [[I:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P]], i64 8
; CHECK-NEXT:    br i1 [[I]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store i64 123, ptr [[G]], align 4
; CHECK-NEXT:    br label [[END:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store i64 321, ptr [[P]], align 4
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %g = getelementptr i8, ptr %p, i64 8
  br i1 %i, label %bb1, label %bb2
bb1:
  store i64 123, ptr %g
  br label %end
bb2:
  store i64 321, ptr %p
  br label %end
end:
  ret void
}

define void @f12(ptr %p, i1 %i) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f12(
; CHECK-SAME: ptr nocapture writeonly initializes((0, 8)) [[P:%.*]], i1 [[I:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[I]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br label [[END:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    store i64 321, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
entry:
  br i1 %i, label %bb1, label %bb2
bb1:
  br label %end
bb2:
  br label %end
end:
  store i64 321, ptr %p
  ret void
}

define void @f13(ptr %p, i1 %i) {
; CHECK-LABEL: define void @f13(
; CHECK-SAME: ptr [[P:%.*]], i1 [[I:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[I]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br label [[END:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    call void @use(ptr [[P]])
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    store i64 321, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
entry:
  br i1 %i, label %bb1, label %bb2
bb1:
  br label %end
bb2:
  call void @use(ptr %p)
  br label %end
end:
  store i64 321, ptr %p
  ret void
}

define void @f14(ptr initializes((33, 36)) %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f14(
; CHECK-SAME: ptr nocapture writeonly initializes((0, 8), (33, 36)) [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    store i64 123, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  store i64 123, ptr %p
  ret void
}

define void @f15(ptr %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f15(
; CHECK-SAME: ptr nocapture writeonly initializes((-5, 3)) [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P]], i64 -5
; CHECK-NEXT:    store i64 123, ptr [[G]], align 4
; CHECK-NEXT:    ret void
;
  %g = getelementptr i8, ptr %p, i64 -5
  store i64 123, ptr %g
  ret void
}

define void @f16(ptr %p, i1 %i) {
; CHECK-LABEL: define void @f16(
; CHECK-SAME: ptr [[P:%.*]], i1 [[I:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @use(ptr [[P]])
; CHECK-NEXT:    br i1 [[I]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store i64 123, ptr [[P]], align 4
; CHECK-NEXT:    br label [[END:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store i64 321, ptr [[P]], align 4
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  call void @use(ptr %p)
  br i1 %i, label %bb1, label %bb2
bb1:
  store i64 123, ptr %p
  br label %end
bb2:
  store i64 321, ptr %p
  br label %end
end:
  ret void
}

declare void @g1(ptr initializes((0, 4)) %p)
declare void @g2(ptr initializes((8, 12)) %p)
declare void @g3(ptr initializes((0, 4)) writeonly nocapture %p)

define void @f17(ptr %p) {
; CHECK-LABEL: define void @f17(
; CHECK-SAME: ptr initializes((0, 4)) [[P:%.*]]) {
; CHECK-NEXT:    call void @g1(ptr [[P]])
; CHECK-NEXT:    ret void
;
  call void @g1(ptr %p)
  ret void
}

define void @f18(ptr %p) {
; CHECK-LABEL: define void @f18(
; CHECK-SAME: ptr initializes((0, 4)) [[P:%.*]]) {
; CHECK-NEXT:    call void @g1(ptr [[P]])
; CHECK-NEXT:    call void @g2(ptr [[P]])
; CHECK-NEXT:    ret void
;
  call void @g1(ptr %p)
  call void @g2(ptr %p)
  ret void
}

define void @f19(ptr %p) {
; CHECK-LABEL: define void @f19(
; CHECK-SAME: ptr initializes((0, 4), (8, 12)) [[P:%.*]]) {
; CHECK-NEXT:    call void @g3(ptr [[P]])
; CHECK-NEXT:    call void @g2(ptr [[P]])
; CHECK-NEXT:    ret void
;
  call void @g3(ptr %p)
  call void @g2(ptr %p)
  ret void
}

declare void @llvm.memset(ptr, i8, i64 ,i1)

define void @f20(ptr %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f20(
; CHECK-SAME: ptr nocapture writeonly initializes((0, 9)) [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr [[P]], i8 2, i64 9, i1 false)
; CHECK-NEXT:    ret void
;
  call void @llvm.memset(ptr %p, i8 2, i64 9, i1 false)
  ret void
}

define void @f21(ptr %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f21(
; CHECK-SAME: ptr nocapture writeonly initializes((3, 12)) [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P]], i64 3
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr [[G]], i8 2, i64 9, i1 false)
; CHECK-NEXT:    ret void
;
  %g = getelementptr i8, ptr %p, i64 3
  call void @llvm.memset(ptr %g, i8 2, i64 9, i1 false)
  ret void
}

define void @f22(ptr %p) {
; CHECK: Function Attrs: mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f22(
; CHECK-SAME: ptr writeonly [[P:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr [[P]], i8 2, i64 9, i1 true)
; CHECK-NEXT:    ret void
;
  call void @llvm.memset(ptr %p, i8 2, i64 9, i1 true)
  ret void
}

declare void @llvm.memcpy(ptr, ptr, i64 ,i1)

define void @f23(ptr %p, ptr %p2) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
; CHECK-LABEL: define void @f23(
; CHECK-SAME: ptr nocapture writeonly initializes((0, 9)) [[P:%.*]], ptr nocapture readonly [[P2:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[P]], ptr [[P2]], i64 9, i1 false)
; CHECK-NEXT:    ret void
;
  call void @llvm.memcpy(ptr %p, ptr %p2, i64 9, i1 false)
  ret void
}

define void @f24(ptr %p, ptr %p2) {
; CHECK: Function Attrs: mustprogress nofree norecurse nounwind willreturn memory(argmem: readwrite)
; CHECK-LABEL: define void @f24(
; CHECK-SAME: ptr writeonly [[P:%.*]], ptr readonly [[P2:%.*]]) #[[ATTR3:[0-9]+]] {
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[P]], ptr [[P2]], i64 9, i1 true)
; CHECK-NEXT:    ret void
;
  call void @llvm.memcpy(ptr %p, ptr %p2, i64 9, i1 true)
  ret void
}

define void @f25(ptr %p, ptr %p2) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
; CHECK-LABEL: define void @f25(
; CHECK-SAME: ptr nocapture writeonly initializes((3, 12)) [[P:%.*]], ptr nocapture readonly [[P2:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P]], i64 3
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[G]], ptr [[P2]], i64 9, i1 false)
; CHECK-NEXT:    ret void
;
  %g = getelementptr i8, ptr %p, i64 3
  call void @llvm.memcpy(ptr %g, ptr %p2, i64 9, i1 false)
  ret void
}

define void @f26(ptr %p, i64 %i) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
; CHECK-LABEL: define void @f26(
; CHECK-SAME: ptr nocapture writeonly initializes((0, 8)) [[P:%.*]], i64 [[I:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P]], i64 [[I]]
; CHECK-NEXT:    store i64 123, ptr [[G]], align 4
; CHECK-NEXT:    store i64 123, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  %g = getelementptr i8, ptr %p, i64 %i
  store i64 123, ptr %g
  store i64 123, ptr %p
  ret void
}
